# Event Publishing Overview for Inventory Service

## 1. Introduction

The Inventory Service is a critical component in the e-commerce platform, responsible for managing stock levels, reservations, and product availability. It employs an event-driven architecture to communicate significant changes in inventory state to other interested microservices. This document outlines the strategy and mechanisms for publishing these domain events.

## 2. Event Publishing Architecture

The Inventory Service utilizes **RabbitMQ** (provisioned via Amazon MQ) as its primary message broker for distributing domain events. Event publishing is facilitated by the shared `@ecommerce-platform/rabbitmq-event-utils` library, which provides standardized message formats and producer/consumer utilities.

```mermaid
graph TD
    A[Inventory Domain Logic] -- Generates event --> B(Event Object: StandardMessage<T>)
    B -- Uses RabbitMQProducerService --> C{RabbitMQ Exchange (e.g., inventory.events)}
    C -- Routing Key --> D1[Queue for Order Service]
    C -- Routing Key --> D2[Queue for Product Service]
    C -- Routing Key --> D3[Queue for Notification Service]
    C -- Routing Key --> D4[Queue for Other Consumers]
    D1 -- Consumed by --> E1[Order Service]
    D2 -- Consumed by --> E2[Product Service]
    D3 -- Consumed by --> E3[Notification Service]
    D4 -- Consumed by --> E4[Other Consumers]
```

Key components:

- **Domain Events**: Represent significant occurrences, e.g., `StockLevelChangedEvent`, `InventoryReservedEvent`.
- **`@ecommerce-platform/rabbitmq-event-utils`**: Provides `RabbitMQProducerService` for publishing and defines the `StandardMessage<T>` envelope.
- **RabbitMQ**: The message broker responsible for routing and delivering events.
- **Exchanges & Queues**: Events are published to specific exchanges (e.g., a topic exchange like `inventory.events`) and routed to bound queues for consumers.

## 3. Event Storage and Distribution Strategy

The Inventory Service may adopt a dual approach for robust event management, although the primary focus for inter-service communication is RabbitMQ:

1.  **Primary Distribution (RabbitMQ)**:

    - Uses the `@ecommerce-platform/rabbitmq-event-utils` library.
    - Events are formatted as `StandardMessage<T>`.
    - Published to RabbitMQ for consumption by other services.
    - Provides reliable delivery with acknowledgments (publisher confirms) and dead-lettering capabilities.

2.  **Optional - Event Store (e.g., DynamoDB or dedicated table - TBD in ADR)**:
    - If implemented, this would serve as the primary historical record of all domain events generated by the Inventory Service.
    - Useful for event sourcing patterns within the service, auditing, debugging, and potential event replay scenarios for the service itself.
    - Events from the event store would then be published to RabbitMQ via an outbox pattern or change data capture (CDC) mechanism to ensure consistency.

## 4. Event Publishing Process (with RabbitMQ)

1.  **Event Creation**: A domain operation within the Inventory Service (e.g., updating stock after a delivery) triggers the creation of an event payload (e.g., `StockLevelChangedPayload`).
2.  **Message Formulation**: The payload is wrapped in the `StandardMessage<T>` envelope. This includes generating a `messageId`, setting the `messageType`, `source`, `timestamp`, `partitionKey` (e.g., `productId`), and `version`.
3.  **Transactional Publishing (Outbox Pattern Recommended)**:
    - To ensure atomicity between state changes in the Inventory Service's database and event publication, the [Outbox Pattern](https://microservices.io/patterns/data/transactional-outbox.html) is highly recommended.
    - The `StandardMessage<T>` is saved to a dedicated "outbox" table within the same database transaction as the business data.
    - A separate process (the "message relay") monitors the outbox table and reliably publishes messages to RabbitMQ using the `RabbitMQProducerService`.
4.  **Publishing to RabbitMQ**: The message relay publishes the event to the designated RabbitMQ exchange (e.g., `inventory.events`) with an appropriate routing key.
5.  **Publisher Confirms**: The `RabbitMQProducerService` should be configured to use publisher confirms to ensure RabbitMQ has successfully received the message.

## 5. Event Schema Management

1.  **Standard Envelope**: All events use the `StandardMessage<T>` envelope from `@ecommerce-platform/rabbitmq-event-utils`.
2.  **Payload Schema Definition**: The `payload` of the `StandardMessage<T>` contains the specific event data. These payload schemas are defined using TypeScript interfaces/types (e.g., `StockLevelChangedPayload`).
3.  **Schema Versioning**: The `version` field within the `StandardMessage<T>` envelope refers to the version of the _payload schema_. This allows for evolving payload structures while consumers can identify the schema version they are dealing with.
4.  **Documentation**: Event payload schemas are documented within this `05-event-publishing` section (e.g., in `01-event-schema-definitions.md`), including sample payloads and the meaning of each field.
5.  **Schema Validation**: Consumers should validate the schema of the events they receive, potentially using the `version` field to apply the correct validation rules.

## 6. Key Event Types and Exchange Strategy

The Inventory Service publishes various events related to stock changes, reservations, and adjustments.

- **Primary Exchange**: `inventory.events` (Topic Exchange)
  - This exchange handles most domain events from the Inventory Service.
  - **Routing Key Convention used by Producer**: The `OutboxProcessorService` typically constructs routing keys in the format `<MessageType>.<partitionKey>` (e.g., `StockLevelChanged.product.PROD123` where `product.PROD123` is the `partitionKey`). These are published to the `inventory.events` exchange.
  - **Example Binding Patterns for Consumers**: Consumers would bind queues to the `inventory.events` exchange using patterns based on these routing keys. For example:
    - To get all stock level changes for a specific product: `StockLevelChanged.product.PROD123`
    - To get all stock level changes for any product: `StockLevelChanged.product.*`
    - To get all inventory reserved events for a specific order: `InventoryReserved.order.ORDER456`
    - To get all events for a specific product: `*.product.PROD123`
- **Specialized Exchanges (Optional)**:
  - `inventory.notifications` (Topic Exchange): For events that might require immediate alerting or specialized handling (e.g., critical stock alerts). Routing keys would follow a similar pattern.
- **Dead Letter Exchange (DLX)**:
  - Queues will be configured with a DLX to route messages that cannot be processed successfully or fail publishing repeatedly.

## 7. Consuming Services (Examples)

Events published by the Inventory Service are consumed by various services, including:

- **Order Service**: To check availability before order placement, confirm reservations, and react to stock changes affecting pending orders.
- **Product Service**: To update product availability information displayed to users (e.g., "in stock", "low stock", "out of stock").
- **Notification Service**: To send alerts for low stock conditions or when a reserved item for a customer order cannot be fulfilled.
- **Analytics Service**: For inventory turnover analysis, stock movement tracking, and forecasting.
- **Purchasing/Replenishment Service**: To trigger reordering processes when stock levels fall below predefined thresholds.

## 8. Further Details

- Specific event payload definitions: See `01-event-schema-definitions.md`
- Implementation details for event publishers: See `02-event-publisher-implementation.md`
- Error handling, idempotency, and security for event publishing will follow the platform-wide standards, referencing `rabbitmq-event-utils` and general ADRs.
